<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage of resizable arrays · ResizableArrays.jl Package</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ResizableArrays.jl Package</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li class="is-active"><a class="tocitem" href>Usage of resizable arrays</a><ul class="internal"><li><a class="tocitem" href="#Creating-a-resizable-array-1"><span>Creating a resizable array</span></a></li><li><a class="tocitem" href="#Resizing-dimensions-1"><span>Resizing dimensions</span></a></li><li><a class="tocitem" href="#Append-or-prepend-contents-1"><span>Append or prepend contents</span></a></li><li><a class="tocitem" href="#Custom-storage-1"><span>Custom storage</span></a></li></ul></li><li><a class="tocitem" href="../library/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage of resizable arrays</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage of resizable arrays</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/emmt/ResizableArrays.jl/blob/master/docs/src/usage.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage-of-resizable-arrays-1"><a class="docs-heading-anchor" href="#Usage-of-resizable-arrays-1">Usage of resizable arrays</a><a class="docs-heading-anchor-permalink" href="#Usage-of-resizable-arrays-1" title="Permalink"></a></h1><p>Instances of ResizableArray can be used as any other Julia multi-dimensional arrays (sub-types of <code>AbstractArray</code>). More specifically and like instances of Julia <code>Array</code>, resizable arrays store their elements contiguously in <a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">column-major storage order</a> and implement fast linear-indexing, . Resizable arrays should be as efficient as instances of <code>Array</code> and can be used wherever an <code>Array</code> instance makes sense including calls to external libraries via the <code>ccall</code> method.</p><h2 id="Creating-a-resizable-array-1"><a class="docs-heading-anchor" href="#Creating-a-resizable-array-1">Creating a resizable array</a><a class="docs-heading-anchor-permalink" href="#Creating-a-resizable-array-1" title="Permalink"></a></h2><p>An unitialized resizable array with elements of type <code>T</code> and dimensions <code>dims</code> is created by:</p><pre><code class="language-julia">ResizableArray{T}(undef, dims)</code></pre><p>Dimensions may be a tuple of integers or a a list of integers. The number <code>N</code> of dimensions may be explicitly specified:</p><pre><code class="language-julia">ResizableArray{T,N}(undef, dims)</code></pre><p>For convenience, <code>ResizableVector{T}</code> and <code>ResizableMatrix{T}</code> are provided as aliases to <code>ResizableArray{T,1}</code> and <code>ResizableArray{T,2}</code>.</p><p>Since a resizable array is <em>resizable</em> its dimensions may be specified at any time (before using its contents). An empty resizable array is simply created by:</p><pre><code class="language-julia">ResizableArray{T,N}()</code></pre><p>The number of dimensions <code>N</code> must be specified in this case. The element type <code>T</code> and the number of dimensions <code>N</code> are part of the signature of the type and cannot be changed without creating a new instance.</p><p>The <code>ResizableArray</code> constructor can be called to create a new resizable array from an existing array <code>A</code> of any kind:</p><pre><code class="language-julia">ResizableArray(A)</code></pre><p>yields a resizable array of same size and element type as <code>A</code> and whose contents is initially copied from that of <code>A</code>.</p><p>Element type <code>T</code> and number of dimensions <code>N</code> may be specified:</p><pre><code class="language-julia">ResizableArray{T}(A)
ResizableArray{T,N}(A)</code></pre><p>where <code>N</code> must match <code>ndims(A)</code> but <code>T</code> may be different from <code>eltype(A)</code>.</p><p>The <code>convert</code> method can be called to convert an existing array <code>A</code> of any kind to a resizable array. There are 3 possibilities:</p><pre><code class="language-julia">convert(ResizableArray, A)
convert(ResizableArray{T}, A)
convert(ResizableArray{T,N}, A)</code></pre><p>where <code>N</code> must match <code>ndims(A)</code> but <code>T</code> may be different from <code>eltype(A)</code>. Unlike the <code>ResizableArray</code> constructor which always returns a new instance, the <code>convert</code> method just returns its argument <code>A</code> if it is already a resizable array whose type has the requested signature. Otherwise, the <code>convert</code> method behaves as the <code>ResizableArray</code> constructor.</p><p>The call <code>copy(ResizableArray,A)</code> yields a copy of <code>A</code> which is a resizable array of same element type as <code>A</code>. Call <code>copy(ResizableArray{T},A)</code> to specify a possibly different element type <code>T</code>. The number of dimensions <code>N</code> may also be specified but it must be the same as <code>A</code>: <code>copy(ResizableArray{T,N},A)</code>.</p><h2 id="Resizing-dimensions-1"><a class="docs-heading-anchor" href="#Resizing-dimensions-1">Resizing dimensions</a><a class="docs-heading-anchor-permalink" href="#Resizing-dimensions-1" title="Permalink"></a></h2><p>The dimensions of a resizable array <code>A</code> may be changed by:</p><pre><code class="language-julia">resize!(A, dims)</code></pre><p>with <code>dims</code> the new dimensions.  The number of dimensions must remain unchanged but the length of the array may change.  Depending on the type of the object backing the storage of the array, it may be possible or not to augment the number of elements of the array.  When array elements are stored in a regular Julia vector, the number of elements can always be augmented (unless too big to fit in memory).  When such a resizable array is resized, its previous contents is preserved if only the last dimension is changed.</p><p>Resizable arrays are designed to re-use storage if possible to avoid calling the garbage collector. This may be useful for real-time applications. As a consequence, the storage used by a resizable array <code>A</code> can only grow unless <code>skrink!(A)</code> is called to reduce the storage to the minimum.</p><h2 id="Append-or-prepend-contents-1"><a class="docs-heading-anchor" href="#Append-or-prepend-contents-1">Append or prepend contents</a><a class="docs-heading-anchor-permalink" href="#Append-or-prepend-contents-1" title="Permalink"></a></h2><p>Calling:</p><pre><code class="language-julia">append!(A, B) -&gt; A</code></pre><p>appends the elements of array <code>B</code> to a resizable array <code>A</code> and, as you may guess, calling:</p><pre><code class="language-julia">prepend!(A, B) -&gt; A</code></pre><p>inserts the elements of <code>B</code> before those of <code>A</code>. Assuming <code>A</code> has <code>N</code> dimensions, array <code>B</code> may have <code>N</code> or <code>N-1</code> dimensions. The <code>N-1</code> first dimensions of <code>B</code> must match the leading dimensions of <code>A</code>, these dimensions are left unchanged in the result. If <code>B</code> has the same number of dimensions as <code>A</code>, the last dimension of the result is the sum of the last dimensions of <code>A</code> and <code>B</code>; otherwise, the last dimension of the result is one plus the last dimension of <code>A</code>.</p><p>The <code>grow!</code> method is able to either append or prepend the elements of an array <code>B</code> to a resizable array <code>A</code>:</p><pre><code class="language-julia">grow!(A, B, prepend=false) -&gt; A</code></pre><p>By default or if argument <code>prepend</code> is <code>false</code>, the elements of <code>B</code> are inserted after those of <code>A</code>; otherwise, the elements of <code>B</code> are inserted before those of <code>A</code>.</p><p>To improve performances of these operations, you can indicate the minimum number of elements for a resizable array <code>A</code>:</p><pre><code class="language-julia">sizehint!(A, len) -&gt; A</code></pre><p>The argument(s) after <code>A</code> may also be a list of dimensions:</p><pre><code class="language-julia">sizehint!(A, dims) -&gt; A</code></pre><p>The method <code>maxlength(A)</code> yields the maximum number of elements that can be stored in array <code>A</code> without resizing its internal buffer.</p><h2 id="Custom-storage-1"><a class="docs-heading-anchor" href="#Custom-storage-1">Custom storage</a><a class="docs-heading-anchor-permalink" href="#Custom-storage-1" title="Permalink"></a></h2><p>The default storage of the elements of a resizable array is provided by a regular Julia vector. To use an object <code>buf</code> to store the elements of a resizable array, use one of the following:</p><pre><code class="language-julia">A = ResizableArray(buf, dims)
A = ResizableArray{T}(buf, dims)
A = ResizableArray{T,N}(buf, dims)</code></pre><p>The buffer <code>buf</code> must store its elements contiguously using linear indexing style with 1-based indices and have element type <code>T</code>, that is <code>IndexStyle(typeof(buf))</code> and <code>eltype(buf)</code> must yield <code>IndexLinear()</code> and <code>T</code> respectively. The methods, <code>IndexStyle</code>, <code>eltype</code>, <code>length</code>, <code>getindex</code> and <code>setindex!</code> must be applicable for the type of <code>buf</code>. If the method <code>resize!</code> is applicable for <code>buf</code>, the number of elements of <code>A</code> can be augmented; otherwise the maximum number of elements of <code>A</code> is <code>length(buf)</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When explictely providing a resizable buffer <code>buf</code> for backing the storage of a resizable array <code>A</code>, you have the responsibility to make sure that the same buffer is not resized elsewhere.  Otherwise a segmentation fault may occur because <code>A</code> might assume a wrong buffer size.  To avoid this, the best is to make sure that only <code>A</code> owns <code>buf</code> and only <code>A</code> manages its size.</p></div></div><p>When using the <code>convert</code> method or the <code>ResizableArray</code> constructor to convert an array into a resizable array, the buffer for backing storage is always an instance of <code>Vector{T}</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../install/">« Installation</a><a class="docs-footer-nextpage" href="../library/">Reference »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 16 July 2023 16:59">Sunday 16 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
