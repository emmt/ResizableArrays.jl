var documenterSearchIndex = {"docs":
[{"location":"usage/#Usage-of-resizable-arrays-1","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"","category":"section"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"Instances of ResizableArray can be used as any other Julia multi-dimensional arrays (sub-types of AbstractArray). More specifically and like instances of Julia Array, resizable arrays store their elements contiguously in column-major storage order and implement fast linear-indexing. Resizable arrays should be as efficient as instances of Array and can be used wherever an Array instance makes sense including calls to external libraries via the ccall method.","category":"page"},{"location":"usage/#Creating-a-resizable-array-1","page":"Usage of resizable arrays","title":"Creating a resizable array","text":"","category":"section"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"An uninitialized resizable array with elements of type T and dimensions dims is created by:","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"ResizableArray{T}(undef, dims)","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"Dimensions may be a tuple of integers or a a list of integers. The number N of dimensions may be explicitly specified:","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"ResizableArray{T,N}(undef, dims)","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"For convenience, ResizableVector{T} and ResizableMatrix{T} are provided as aliases to ResizableArray{T,1} and ResizableArray{T,2}.","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"Since a resizable array is resizable its dimensions may be specified at any time (before using its contents). An empty resizable array is simply created by:","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"ResizableArray{T,N}()","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"The number of dimensions N must be specified in this case. The element type T and the number of dimensions N are part of the signature of the type and cannot be changed without creating a new instance.","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"The ResizableArray constructor can be called to create a new resizable array from an existing array A of any kind:","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"ResizableArray(A)","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"yields a resizable array of same size and element type as A and whose contents is initially copied from that of A.","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"Element type T and number of dimensions N may be specified:","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"ResizableArray{T}(A)\nResizableArray{T,N}(A)","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"where N must match ndims(A) but T may be different from eltype(A).","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"The convert method can be called to convert an existing array A of any kind to a resizable array. There are 3 possibilities:","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"convert(ResizableArray, A)\nconvert(ResizableArray{T}, A)\nconvert(ResizableArray{T,N}, A)","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"where N must match ndims(A) but T may be different from eltype(A). Unlike the ResizableArray constructor which always returns a new instance, the convert method just returns its argument A if it is already a resizable array whose type has the requested signature. Otherwise, the convert method behaves as the ResizableArray constructor.","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"The call ResizableArray(A) yields a copy of A which is a resizable array of same element type as A. Call ResizableArray{T}(A) to specify a possibly different element type T. The number of dimensions N may also be specified but it must be the same as A: ResizableArray{T,N}(A).","category":"page"},{"location":"usage/#Resizing-dimensions-1","page":"Usage of resizable arrays","title":"Resizing dimensions","text":"","category":"section"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"The dimensions of a resizable array A may be changed by:","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"resize!(A, dims)","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"with dims the new dimensions. The number of dimensions must remain unchanged but the length of the array may change. Depending on the type of the object backing the storage of the array, it may be possible or not to augment the number of elements of the array. When array elements are stored in a regular Julia vector, the number of elements can always be augmented (unless too big to fit in memory). When such a resizable array is resized, its previous contents is preserved if only the last dimension is changed.","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"Resizable arrays are designed to re-use storage if possible to avoid calling the garbage collector. This may be useful for real-time applications. As a consequence, the storage used by a resizable array A can only grow unless skrink!(A) is called to reduce the storage to the minimum.","category":"page"},{"location":"usage/#Append-or-prepend-contents-1","page":"Usage of resizable arrays","title":"Append or prepend contents","text":"","category":"section"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"Calling:","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"append!(A, B) -> A","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"appends the elements of array B to a resizable array A and, as you may guess, calling:","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"prepend!(A, B) -> A","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"inserts the elements of B before those of A. Assuming A has N dimensions, array B may have N or N-1 dimensions. The N-1 first dimensions of B must match the leading dimensions of A, these dimensions are left unchanged in the result. If B has the same number of dimensions as A, the last dimension of the result is the sum of the last dimensions of A and B; otherwise, the last dimension of the result is one plus the last dimension of A.","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"The grow! method is able to either append or prepend the elements of an array B to a resizable array A:","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"grow!(A, B, prepend=false) -> A","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"By default or if argument prepend is false, the elements of B are inserted after those of A; otherwise, the elements of B are inserted before those of A.","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"To improve performances of these operations, you can indicate the minimum number of elements for a resizable array A:","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"sizehint!(A, len) -> A","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"The argument(s) after A may also be a list of dimensions:","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"sizehint!(A, dims) -> A","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"The method maxlength(A) yields the maximum number of elements that can be stored in array A without resizing its internal buffer.","category":"page"},{"location":"usage/#Custom-storage-1","page":"Usage of resizable arrays","title":"Custom storage","text":"","category":"section"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"The default storage of the elements of a resizable array is provided by a regular Julia vector. To use an object buf to store the elements of a resizable array, use one of the following:","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"A = ResizableArray(buf, dims)\nA = ResizableArray{T}(buf, dims)\nA = ResizableArray{T,N}(buf, dims)","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"The buffer buf must store its elements contiguously using linear indexing style with 1-based indices and have element type T, that is IndexStyle(typeof(buf)) and eltype(buf) must yield IndexLinear() and T respectively. The methods, IndexStyle, eltype, length, getindex and setindex! must be applicable for the type of buf. If the method resize! is applicable for buf, the number of elements of A can be augmented; otherwise the maximum number of elements of A is length(buf).","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"warning: Warning\nWhen explicitly providing a resizable buffer buf for backing the storage of a resizable array A, it is the caller responsibility to make sure that the same buffer is not resized elsewhere. Otherwise a segmentation fault may occur because A might assume a wrong buffer size. To avoid this, the best is to make sure that only A owns buf and only A manages its size. In the current implementation, the size of the internal buffer is never automatically reduced so the same buffer may be safely shared by different resizable arrays provided shrink! is never called on these arrays.","category":"page"},{"location":"usage/#","page":"Usage of resizable arrays","title":"Usage of resizable arrays","text":"When using the convert method or the ResizableArray constructor to convert an array into a resizable array, the buffer for backing storage is always an instance of Vector{T}.","category":"page"},{"location":"library/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"The following provides detailed documentation about types and methods provided by the ResizableArrays package. This information is also available from the REPL by typing ? followed by the name of a method or a type.","category":"page"},{"location":"library/#","page":"Reference","title":"Reference","text":"ResizableArrays.ResizableArray","category":"page"},{"location":"library/#ResizableArrays.ResizableArray","page":"Reference","title":"ResizableArrays.ResizableArray","text":"ResizableArray{T}(undef, dims...)\n\nyields a resizable array with un-initialized elements of type T and dimensions dims.... Dimensions may be a tuple of integers or a a list of integers. The number N of dimensions may be explicitly specified:\n\nResizableArray{T,N}(undef, dims...)\n\nTo create an empty resizable array of given rank and element type, call:\n\nResizableArray{T,N}()\n\nThe dimensions of a resizable array A may be changed by calling resize!(A,dims) with dims the new dimensions. The number of dimensions must remain unchanged but the length of the array may change. Depending on the type of the object backing the storage of the array, it may be possible or not to augment the number of elements of the array. When array elements are stored in a regular Julia vector, the number of element can always be augmented. Changing only the last dimension of a resizable array preserves its contents.\n\nResizable arrays are designed to re-use storage if possible to avoid calling the garbage collector. This may be useful for real-time applications. As a consequence, the storage used by a resizable array A can only grow unless shrink!(A) is called to reduce the storage to the minimum. The call ResizableArray(A) yields a copy of A which is a resizable array.\n\nTo improve performances, call sizehint!(A,n) to indicate the minimum number of elements to preallocate for A (n can be a number of elements or array dimensions).\n\nThe ResizableArray constructor and the convert method can be used to convert an array A to a resizable array:\n\nResizableArray(A)\nconvert(ResizableArray, A)\n\nIf possible, the convert method returns the input array while the ResizableArray constructor always returns a new instance. Element type T and number of dimensions N may be specified:\n\nResizableArray{T[,N]}(A)\nconvert(ResizableArray{T[,N]}, A)\n\nN must match ndims(A) but T may be different from eltype(A).\n\nBy default, the storage for the elements of a resizable array is provided by a regular Julia vector. To use an object buf to store the elements of a resizable array, use one of the following:\n\nA = ResizableArray(buf, dims)\nA = ResizableArray{T}(buf, dims)\nA = ResizableArray{T,N}(buf, dims)\n\nThe buffer buf must store its elements contiguously using linear indexing style with 1-based indices and have element type T, that is IndexStyle(typeof(buf)) and eltype(buf) must yield IndexLinear() and T respectively. The methods, IndexStyle, eltype, length, getindex and setindex! must be applicable for the type of buf. If the method resize! is applicable for buf, the number of elements of A can be augmented; otherwise the maximum number of elements of A is length(buf).\n\nwarning: Warning\nWhen explicitly providing a resizable buffer buf for backing the storage of a resizable array A, it is the caller responsibility to make sure that the same buffer is not resized elsewhere. Otherwise a segmentation fault may occur because A might assume a wrong buffer size. To avoid this, the best is to make sure that only A owns buf and only A manages its size. In the current implementation, the size of the internal buffer is never automatically reduced so the same buffer may be safely shared by different resizable arrays provided shrink! is never called on these arrays.\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Reference","title":"Reference","text":"ResizableArrays.ResizableMatrix","category":"page"},{"location":"library/#ResizableArrays.ResizableMatrix","page":"Reference","title":"ResizableArrays.ResizableMatrix","text":"ResizableMatrix{T}\n\nis the supertype of two-dimensional resizable arrays with elements of type T. Alias for ResizableArray{T,2}.\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Reference","title":"Reference","text":"ResizableArrays.ResizableVector","category":"page"},{"location":"library/#ResizableArrays.ResizableVector","page":"Reference","title":"ResizableArrays.ResizableVector","text":"ResizableVector{T}\n\nis the supertype of one-dimensional resizable arrays with elements of type T. Alias for ResizableArray{T,1}.\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Reference","title":"Reference","text":"ResizableArrays.isgrowable","category":"page"},{"location":"library/#ResizableArrays.isgrowable","page":"Reference","title":"ResizableArrays.isgrowable","text":"isgrowable(x) -> boolean\n\nyields whether x is a growable object, that is its size can be augmented.\n\n\n\n\n\n","category":"function"},{"location":"library/#","page":"Reference","title":"Reference","text":"ResizableArrays.maxlength","category":"page"},{"location":"library/#ResizableArrays.maxlength","page":"Reference","title":"ResizableArrays.maxlength","text":"maxlength(A)\n\nyields the maximum number of elements which can be stored in resizable array A without resizing its internal buffer.\n\nSee also: ResizableArray.\n\n\n\n\n\n","category":"function"},{"location":"library/#","page":"Reference","title":"Reference","text":"ResizableArrays.grow!","category":"page"},{"location":"library/#ResizableArrays.grow!","page":"Reference","title":"ResizableArrays.grow!","text":"grow!(A, B, prepend=false) -> A\n\ngrows resizable array A with the elements of B and returns A. If prepend is true, the elements of B are inserted before those of A; otherwise, the elements of B are appended after those of A. By default, prepend is false.\n\nAssuming A has N dimensions, array B may have N or N-1 dimensions. The N-1 leading dimensions of A and B must be identical and are the leading dimensions of the result. If B has the same number of dimensions as A, the last dimension of the result is the sum of the last dimensions of A and B; otherwise, the last dimension of the result is one plus the last dimension of A.\n\nDepending on argument prepend, calling the grow! method is equivalent to calling append! or prepend! methods.\n\nSee also ResizableArray.\n\n\n\n\n\n","category":"function"},{"location":"library/#","page":"Reference","title":"Reference","text":"ResizableArrays.shrink!","category":"page"},{"location":"library/#ResizableArrays.shrink!","page":"Reference","title":"ResizableArrays.shrink!","text":"shrink!(A) -> A\n\nshrinks as much as possible the storage of resizable array A and returns A. Call ResizableArray(A) to make a copy of A which is a resizable array with shrunk storage.\n\n\n\n\n\n","category":"function"},{"location":"install/#Installation-1","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#","page":"Installation","title":"Installation","text":"ResizableArrays is an offical Julia package so you just have to type:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"pkg> add ResizableArrays","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"at Julia package manager prompt (at the REPL of Julia, hit the ] key to switch to the package manager prompt and hit the BackSpace key to return to Julia's prompt).","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"If you want to stick to the master branch, do:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"pkg> add ResizableArrays#master","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"instead.","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The ResizableArray package provides multi-dimensional arrays which are resizable and which are intended to be as efficient as Julia arrays. This circumvents the Julia limitation that only uni-dimensional arrays (of type Vector) are resizable. The only restriction is that the number of dimensions of a resizable array must be left unchanged.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Resizable arrays may be useful in a variety of situations. For instance to avoid re-creating arrays and therefore to limit the calls to Julia garbage collector which may be very costly for real-time applications.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Unlike ElasticArrays which provides arrays that can grow and shrink, but only in their last dimension, any dimensions of ResizableArray instances can be changed (providing the number of dimensions remain the same). Another difference is that you may use a custom Julia object to store the elements of a resizable array, not just a Vector{T}.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The source code of ResizableArrays is available on GitHub.","category":"page"},{"location":"#Table-of-contents-1","page":"Introduction","title":"Table of contents","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\"install.md\", \"usage.md\", \"library.md\"]","category":"page"},{"location":"#Index-1","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
